package main

const TypesGovmomiTemplate = `
// Code generated by protoc-gen-go-govmomi-bridge. DO NOT EDIT.
package {{.GoPackageName}}

import (
	"encoding/json"
	"fmt"
	"reflect"
	"strings"
	"sync"
	"time"

	"google.golang.org/protobuf/types/known/timestamppb"
)


// FromGovmomi copies the value of src govmomi struct to dst proto message
func FromGovmomi(src any, dst any) error {
	srcValue := getRealValue(reflect.ValueOf(src))
	dstValue := getRealValue(reflect.ValueOf(dst))

	srcType := getRealType(srcValue.Type())
	dstType := getRealType(dstValue.Type())

	// for primitive types, just convert
	if srcType.Kind() != reflect.Struct &&
		dstType.Kind() != reflect.Struct &&
		(srcType.AssignableTo(dstType) || srcType.ConvertibleTo(dstType)) {
		dstValue.Set(srcValue.Convert(dstType))

		return nil
	}

	// handle unknown types
	if srcType.Kind() != reflect.Struct && dstType.Kind() != reflect.Struct {
		return fmt.Errorf("non-struct types %s %s", srcType.Kind(), dstType.Kind())
	}

	// flatten the struct to get all fields
	srcFields := flattenStruct(srcType)

	for _, srcField := range srcFields {
		srcFieldValue := fieldByNameOrZeroValue(srcValue, srcField.Name)

		for j := 0; j < dstType.NumField(); j++ {
			dstField := dstType.Field(j)
			dstFieldValue := dstValue.Field(j)

			// try to match field name
			if !match(srcField, dstField) {
				continue
			}

			// if srcField is an interface{}, we need to convert it to []byte
			if srcFieldValue.Kind() == reflect.Interface {
				// if srcField is nil, we don't need to copy
				if srcFieldValue.IsNil() {
					break
				}
				srcFieldValue = srcFieldValue.Elem()

			}

			// if srcField is a pointer, we need to dereference it
			if srcFieldValue.Kind() == reflect.Ptr {
				// if srcField is nil, we don't need to copy
				if srcFieldValue.IsNil() {
					break
				}
				srcFieldValue = srcFieldValue.Elem()
			}

			// if dstField is a pointer, we need to allocate memory for it
			if dstFieldValue.Kind() == reflect.Ptr {
				// if dstField is nil, we need to allocate memory for it
				if dstFieldValue.IsNil() {
					dstFieldValue.Set(reflect.New(dstFieldValue.Type().Elem()))
				}
				dstFieldValue = dstFieldValue.Elem()
			}

			// handle time
			// convert govmomi time (*time.Time) to proto time (*timestamppb.Timestamp)
			// NOTE: proto time has no timezone or monotonic clock information
			if srcFieldValue.Type().AssignableTo(reflect.TypeOf(time.Now())) &&
				dstFieldValue.Type().AssignableTo(reflect.TypeOf((*timestamppb.Timestamp)(nil)).Elem()) {

				// if srcField is nil, we don't need to copy
				if !srcFieldValue.IsValid() {
					break
				}

				// convert govmomi time to proto time
				dstFieldValue.Set(reflect.ValueOf(timestamppb.New(srcFieldValue.Interface().(time.Time))).Elem())
			}

			// srcField and dstField are of different kinds
			// source: https://github.com/jinzhu/copier/issues/84
			if srcFieldValue.Kind() != dstFieldValue.Kind() {

				// handle enum
				// convert govmomi enum (string) to proto enum (int32)
				if srcFieldValue.Kind() == reflect.String && dstFieldValue.Kind() == reflect.Int32 {
					// if srcField is an empty string, ignore it
					if srcFieldValue.String() == "" {
						break
					}

					// check if target field implement Enum interface
					if _, ok := dstFieldValue.Addr().Interface().(Enum); !ok {
						return fmt.Errorf("field %s does not implement Enum interface", dstField.Name)
					}

					// call FromGovmomi to convert govmomi enum to proto enum
					dstFieldValue.Addr().Interface().(Enum).FromGovmomi(srcFieldValue.String())

					break
				}

				// handle any
				// convert govmomi any (interface{}) to Any
				if dstFieldValue.Type().AssignableTo(reflect.TypeOf((*Any)(nil)).Elem()) {
					// marshal govmomi any to []byte
					b, err := json.Marshal(srcFieldValue.Interface())
					if err != nil {
						return fmt.Errorf("failed to marshal %s: %v", srcField.Name, err)
					}

					// create a anypb.Any and assign the []byte value to it
					any := &Any{
						Value: b,
					}

					// set the anypb.Any to dstFieldValue
					dstFieldValue.Set(reflect.ValueOf(any).Elem())
					break
				}

				return fmt.Errorf("matched fields with various value type: %s:%s, %s:%s", srcField.Name, srcFieldValue.Kind(), dstField.Name, dstFieldValue.Kind())
			}

			// handle slice
			if srcFieldValue.Kind() == reflect.Slice && dstFieldValue.Kind() == reflect.Slice {
				// if srcField is an empty slice, ignore it
				if srcFieldValue.IsNil() {
					break
				}

				// if dstField is an empty slice, we need to allocate memory for it
				if dstFieldValue.IsNil() {
					slice := reflect.MakeSlice(reflect.SliceOf(dstFieldValue.Type().Elem()), srcFieldValue.Len(), srcFieldValue.Cap())
					dstFieldValue.Set(slice)
				}

				for i := 0; i < srcFieldValue.Len(); i++ {
					srcElem := srcFieldValue.Index(i)
					dstElem := dstFieldValue.Index(i)

					// if srcElem is a pointer, we need to dereference it
					if srcElem.Kind() == reflect.Ptr {
						// if srcElem is nil, we don't need to copy
						if srcElem.IsNil() {
							continue
						}
						srcElem = srcElem.Elem()
					}

					// if dstElem is a pointer, we need to allocate memory for it
					if dstElem.Kind() == reflect.Ptr {
						// if dstElem is nil, we need to allocate memory for it
						if dstElem.IsNil() {
							dstElem.Set(reflect.New(dstElem.Type().Elem()))
						}
						dstElem = dstElem.Elem()
					}

					// if srcElem is a struct, we need to recursively copy
					if srcElem.Kind() == reflect.Struct {
						if err := FromGovmomi(srcElem.Interface(), dstElem.Addr().Interface()); err != nil {
							return err
						}
					} else {
						// for primitive types, just convert and return
						dstElem.Set(srcElem)
					}
				}

				break

			} else if srcFieldValue.Kind() == reflect.Struct && dstFieldValue.Kind() == reflect.Struct {
				// for nested structs, we need to recursively copy
				if err := FromGovmomi(srcFieldValue.Interface(), dstFieldValue.Addr().Interface()); err != nil {
					return err
				}
			} else {
				// for primitive types, just convert and return
				dstFieldValue.Set(srcFieldValue)
				break
			}
		}
	}

	return nil
}

// fieldByNameOrZeroValue returns the field value of the given field name, or zero value if not found.
// Credit to https://github.com/jinzhu/copier
func fieldByNameOrZeroValue(source reflect.Value, fieldName string) (value reflect.Value) {
	defer func() {
		if err := recover(); err != nil {
			value = reflect.Value{}
		}
	}()

	return source.FieldByName(fieldName)
}

var (
	deepFieldsLock sync.RWMutex
	deepFieldsMap  = make(map[reflect.Type][]reflect.StructField)
)

// flattenStruct returns all fields of the given type, including anonymous fields.
// Credit to https://github.com/jinzhu/copier
func flattenStruct(reflectType reflect.Type) []reflect.StructField {
	deepFieldsLock.RLock()
	cache, ok := deepFieldsMap[reflectType]
	deepFieldsLock.RUnlock()
	if ok {
		return cache
	}
	var res []reflect.StructField
	if reflectType = getRealType(reflectType); reflectType.Kind() == reflect.Struct {
		fields := make([]reflect.StructField, 0, reflectType.NumField())

		for i := 0; i < reflectType.NumField(); i++ {
			v := reflectType.Field(i)
			// PkgPath is the package path that qualifies a lower case (unexported)
			// field name. It is empty for upper case (exported) field names.
			// See https://golang.org/ref/spec#Uniqueness_of_identifiers
			if v.PkgPath == "" {
				fields = append(fields, v)
				if v.Anonymous {
					// also consider fields of anonymous fields as fields of the root
					fields = append(fields, flattenStruct(v.Type)...)
				}
			}
		}
		res = fields
	}

	deepFieldsLock.Lock()
	deepFieldsMap[reflectType] = res
	deepFieldsLock.Unlock()
	return res
}

// match returns whether the govmomi srcField and nimbus dstField are matched.
// For govmomi field, we use the xml tag.
// For nimbus field, we use the protobuf tag.
func match(srcField, dstField reflect.StructField) bool {
	// first handle source govmomi field
	srcFieldName := srcField.Tag.Get("xml")

	// remove ,omitempty
	if strings.Contains(srcFieldName, ",omitempty") {
		srcFieldName = strings.Split(srcFieldName, ",")[0]
	}

	// remove ,typeattr
	if strings.Contains(srcFieldName, ",typeattr") {
		srcFieldName = strings.Split(srcFieldName, ",")[0]
	}

	// hack for govmomi ManagedObjectReference
	if srcFieldName == "type,attr" {
		srcFieldName = "type"
	}

	if srcFieldName == ",chardata" {
		srcFieldName = "value"
	}

	if srcFieldName == "_this" {
		srcFieldName = "this"
	}

	// then handle destination nimbus field
	dstFieldTag := dstField.Tag.Get("protobuf")
	if dstFieldTag == "" {
		return false
	}

	// get name from tag = 'bytes,1,opt,name=network,proto3,oneof'
	dstFieldKvStr := strings.Split(dstFieldTag, ",")[3]
	dstFieldName := strings.Split(dstFieldKvStr, "=")[1]

	return srcFieldName == dstFieldName
}

// getRealValue returns the real value of reflect.Value
func getRealValue(reflectValue reflect.Value) reflect.Value {
	for reflectValue.Kind() == reflect.Ptr {
		reflectValue = reflectValue.Elem()
	}
	return reflectValue
}

// getRealType returns the real type of reflect.Type, and whether it is a pointer
func getRealType(reflectType reflect.Type) (_ reflect.Type) {
	for reflectType.Kind() == reflect.Ptr || reflectType.Kind() == reflect.Slice {
		reflectType = reflectType.Elem()
	}
	return reflectType
}
`
